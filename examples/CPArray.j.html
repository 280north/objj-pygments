<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=latin1">
  <style type="text/css">
td.linenos { background-color: #f0f0f0; padding-right: 10px; }
span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }
pre { line-height: 125%; }
body .hll { background-color: #ffffcc }
body  { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #808080 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0040D0 } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * CPArray.j</span>
<span class="cm"> * Foundation</span>
<span class="cm"> *</span>
<span class="cm"> * Created by Francisco Tolmasky.</span>
<span class="cm"> * Copyright 2008, 280 North, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * This library is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU Lesser General Public</span>
<span class="cm"> * License as published by the Free Software Foundation; either</span>
<span class="cm"> * version 2.1 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This library is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<span class="cm"> * Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU Lesser General Public</span>
<span class="cm"> * License along with this library; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="cm"> */</span>

<span class="cp">@import</span> <span class="s2">&quot;CPObject.j&quot;</span>
<span class="cp">@import</span> <span class="s2">&quot;CPRange.j&quot;</span>
<span class="cp">@import</span> <span class="s2">&quot;CPEnumerator.j&quot;</span>
<span class="cp">@import</span> <span class="s2">&quot;CPSortDescriptor.j&quot;</span>
<span class="cp">@import</span> <span class="s2">&quot;CPException.j&quot;</span>


<span class="cm">/* @ignore */</span>
<span class="k">@implementation</span> <span class="nc">_CPArrayEnumerator</span> <span class="o">:</span> <span class="nc">CPEnumerator</span>
<span class="p">{</span>
    <span class="n">CPArray</span> <span class="n">_array</span><span class="p">;</span>
    <span class="kt">int</span>     <span class="n">_index</span><span class="p">;</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_array</span> <span class="o">=</span> <span class="n">anArray</span><span class="p">;</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">nextObject</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">_index</span> <span class="o">&gt;=</span> <span class="p">[</span><span class="n">_array</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">_array</span> <span class="n">objectAtIndex</span><span class="o">:</span><span class="n">_index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="cm">/* @ignore */</span>
<span class="k">@implementation</span> <span class="nc">_CPReverseArrayEnumerator</span> <span class="o">:</span> <span class="nc">CPEnumerator</span>
<span class="p">{</span>
    <span class="n">CPArray</span> <span class="n">_array</span><span class="p">;</span>
    <span class="kt">int</span>     <span class="n">_index</span><span class="p">;</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_array</span> <span class="o">=</span> <span class="n">anArray</span><span class="p">;</span>
        <span class="n">_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">_array</span> <span class="n">count</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">nextObject</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">_array</span> <span class="n">objectAtIndex</span><span class="o">:</span><span class="n">_index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="cm">/*! </span>
<span class="cm">    @class CPArray</span>
<span class="cm">    @brief A mutable array backed by a JavaScript Array.</span>
<span class="cm">    @ingroup foundation</span>

<span class="cm">    A mutable array class backed by a JavaScript Array.</span>
<span class="cm">    There is also a CPMutableArray class,</span>
<span class="cm">    but it is just a child class of this class with an</span>
<span class="cm">    empty implementation. All mutable functionality is</span>
<span class="cm">    implemented directly in CPArray.</span>
<span class="cm">*/</span>
<span class="k">@implementation</span> <span class="nc">CPArray</span> <span class="o">:</span> <span class="nc">CPObject</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a new uninitialized CPArray.</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">alloc</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a new initialized CPArray.</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">array</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Creates a new array containing the objects in \c anArray.</span>
<span class="cm">    @param anArray Objects in this array will be added to the new array</span>
<span class="cm">    @return a new CPArray of the provided objects</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">arrayWithArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithArray</span><span class="o">:</span><span class="n">anArray</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Creates a new array with \c anObject in it.</span>
<span class="cm">    @param anObject the object to be added to the array</span>
<span class="cm">    @return a new CPArray containing a single object</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">arrayWithObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithObjects</span><span class="o">:</span><span class="n">anObject</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Creates a new CPArray containing all the objects passed as arguments to the method.</span>
<span class="cm">    @param anObject the objects that will be added to the new array</span>
<span class="cm">    @return a new CPArray containing the argument objects</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">arrayWithObjects:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject<span class="p">,</span> <span class="p">...</span>
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">array</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">],</span>
        <span class="n">argument</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arguments</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">argument</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">array</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Creates a CPArray from a JavaScript array of objects.</span>
<span class="cm">    @param objects the JavaScript Array</span>
<span class="cm">    @param aCount the number of objects in the JS Array</span>
<span class="cm">    @return a new CPArray containing the specified objects</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">arrayWithObjects:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>objects <span class="nf">count:</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>aCount
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithObjects</span><span class="o">:</span><span class="n">objects</span> <span class="n">count</span><span class="o">:</span><span class="n">aCount</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Initializes the CPArray.</span>
<span class="cm">    @return the initialized array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Creating an Array</span>
<span class="cm">/*!</span>
<span class="cm">    Creates a new CPArray from \c anArray.</span>
<span class="cm">    @param anArray objects in this array will be added to the new array</span>
<span class="cm">    @return a new CPArray containing the objects of \c anArray</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">setArray</span><span class="o">:</span><span class="n">anArray</span><span class="p">];</span>
    
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Initializes a the array with the contents of \c anArray</span>
<span class="cm">    and optionally performs a deep copy of the objects based on \c copyItems.</span>
<span class="cm">    @param anArray the array to copy the data from</span>
<span class="cm">    @param copyItems if \c YES, each object will be copied by having a \c -copy message sent to it, and the</span>
<span class="cm">    returned object will be added to the receiver. Otherwise, no copying will be performed.</span>
<span class="cm">    @return the initialized array of objects</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray <span class="nf">copyItems:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span>copyItems
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copyItems</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">initWithArray</span><span class="o">:</span><span class="n">anArray</span><span class="p">];</span>

    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">count</span><span class="p">];</span>
            
        <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">anArray</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isa</span><span class="p">)</span>
                <span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">copy</span><span class="p">];</span>
            <span class="c1">// Do a deep/shallow copy?</span>
            <span class="k">else</span>
                <span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">anArray</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    initializes an array with the contents of anArray</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithObjects:</span><span class="p">(</span><span class="kt">Array</span><span class="p">)</span>anArray<span class="p">,</span> <span class="p">...</span>
<span class="p">{</span>
    <span class="c1">// The arguments array contains self and _cmd, so the first object is at position 2.</span>
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">argument</span><span class="p">;</span>
    
    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arguments</span><span class="p">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">argument</span> <span class="o">=</span> <span class="n">arguments</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="nf">push</span><span class="p">(</span><span class="n">argument</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Initializes the array with a JavaScript array of objects.</span>
<span class="cm">    @param objects the array of objects to add to the receiver</span>
<span class="cm">    @param aCount the number of objects in \c objects</span>
<span class="cm">    @return the initialized CPArray</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithObjects:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>objects <span class="nf">count:</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>aCount
<span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
        <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">aCount</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
            <span class="nf">push</span><span class="p">(</span><span class="n">objects</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Querying an array</span>
<span class="cm">/*!</span>
<span class="cm">    Returns \c YES if the array contains \c anObject. Otherwise, it returns \c NO.</span>
<span class="cm">    @param anObject the method checks if this object is already in the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">containsObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">indexOfObject</span><span class="o">:</span><span class="n">anObject</span><span class="p">]</span> <span class="o">!=</span> <span class="n">CPNotFound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the number of elements in the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">count</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in this array.</span>
<span class="cm">    If the object is \c nil or not in the array,</span>
<span class="cm">    returns \c CPNotFound. It first attempts to find</span>
<span class="cm">    a match using \c -isEqual:, then \c ==.</span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span> <span class="o">===</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
    
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

    <span class="c1">// Only use -isEqual: if our object is a CPObject.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span><span class="p">.</span><span class="n">isa</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span><span class="p">([</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">isEqual</span><span class="o">:</span><span class="n">anObject</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// If indexOf exists, use it since it&#39;s probably </span>
    <span class="c1">// faster than anything we can implement.</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">indexOf</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">indexOf</span><span class="p">(</span><span class="n">anObject</span><span class="p">);</span>
    <span class="c1">// Last resort, do a straight forward linear O(N) search.</span>
    <span class="k">else</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">anObject</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array</span>
<span class="cm">    within \c aRange. It first attempts to find</span>
<span class="cm">    a match using \c -isEqual:, then \c ==.</span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @param aRange the range to search within</span>
<span class="cm">    @return the index of the object, or \c CPNotFound if it was not found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">inRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span> <span class="o">===</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
    
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="kc">MIN</span><span class="p">(</span><span class="nf">CPMaxRange</span><span class="p">(</span><span class="n">aRange</span><span class="p">),</span> <span class="n">length</span><span class="p">);</span>
    
    <span class="c1">// Only use isEqual: if our object is a CPObject.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span><span class="p">.</span><span class="n">isa</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span><span class="p">([</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">isEqual</span><span class="o">:</span><span class="n">anObject</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Last resort, do a straight forward linear O(N) search.</span>
    <span class="k">else</span>
        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">anObject</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array. The test for equality is done using only \c ==.</span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @return the index of the object in the array. \c CPNotFound if the object is not in the array.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">indexOfObjectIdenticalTo:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span> <span class="o">===</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
    
    <span class="c1">// If indexOf exists, use it since it&#39;s probably </span>
    <span class="c1">// faster than anything we can implement.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">indexOf</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">indexOf</span><span class="p">(</span><span class="n">anObject</span><span class="p">);</span>
    
    <span class="c1">// Last resort, do a straight forward linear O(N) search.</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
            <span class="n">count</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
        
        <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">===</span> <span class="n">anObject</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array</span>
<span class="cm">    within \c aRange. The test for equality is</span>
<span class="cm">    done using only \c ==.</span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @param aRange the range to search within</span>
<span class="cm">    @return the index of the object, or \c CPNotFound if it was not found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nf">indexOfObjectIdenticalTo:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">inRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span> <span class="o">===</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
    
    <span class="c1">// If indexOf exists, use it since it&#39;s probably </span>
    <span class="c1">// faster than anything we can implement.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">indexOf</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="nf">indexOf</span><span class="p">(</span><span class="n">anObject</span><span class="p">,</span> <span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nf">CPLocationInRange</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">aRange</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Last resort, do a straight forward linear O(N) search.</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> 
            <span class="n">count</span> <span class="o">=</span> <span class="kc">MIN</span><span class="p">(</span><span class="nf">CPMaxRange</span><span class="p">(</span><span class="n">aRange</span><span class="p">),</span> <span class="n">length</span><span class="p">);</span>
        
        <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">anObject</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array, which must be sorted in the same order as</span>
<span class="cm">    calling sortUsingSelector: with the selector passed to this method would result in. </span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @param aSelector the comparison selector to call on each item in the list, the same</span>
<span class="cm">    selector should have been used to sort the array (or to maintain its sorted order).</span>
<span class="cm">    @return the index of the object, or \c CPNotFound if it was not found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">sortedBySelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span>aSelector
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">indexOfObject</span><span class="o">:</span><span class="n">anObject</span> <span class="n">sortedByFunction</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="nf">objj_msgSend</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">}];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array, which must be sorted in the same order as</span>
<span class="cm">    calling sortUsingFunction: with the selector passed to this method would result in. </span>
<span class="cm">    The function will be called like so:</span>
<span class="cm">    &lt;pre&gt;</span>
<span class="cm">    aFunction(anObject, currentObjectInArrayForComparison)</span>
<span class="cm">    &lt;/pre&gt;</span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @param aFunction the comparison function to call on each item in the array that we search. the same</span>
<span class="cm">    selector should have been used to sort the array (or to maintain its sorted order).</span>
<span class="cm">    @return the index of the object, or \c CPNotFound if it was not found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">sortedByFunction:</span><span class="p">(</span><span class="kt">Function</span><span class="p">)</span>aFunction
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">indexOfObject</span><span class="o">:</span><span class="n">anObject</span> <span class="n">sortedByFunction</span><span class="o">:</span><span class="n">aFunction</span> <span class="n">context</span><span class="o">:</span><span class="kc">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array, which must be sorted in the same order as</span>
<span class="cm">    calling sortUsingFunction: with the selector passed to this method would result in. </span>
<span class="cm">    The function will be called like so:</span>
<span class="cm">    &lt;pre&gt;</span>
<span class="cm">    aFunction(anObject, currentObjectInArrayForComparison, context)</span>
<span class="cm">    &lt;/pre&gt;</span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @param aFunction the comparison function to call on each item in the array that we search. the same</span>
<span class="cm">    function should have been used to sort the array (or to maintain its sorted order).</span>
<span class="cm">    @param aContext a context object that will be passed to the sort function</span>
<span class="cm">    @return the index of the object, or \c CPNotFound if it was not found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">sortedByFunction:</span><span class="p">(</span><span class="kt">Function</span><span class="p">)</span>aFunction <span class="nf">context:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>aContext
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aFunction</span> <span class="o">||</span> <span class="n">anObject</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>

    <span class="kd">var</span> <span class="n">mid</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">&lt;=</span> <span class="n">last</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="kc">FLOOR</span><span class="p">((</span><span class="n">first</span> <span class="o">+</span> <span class="n">last</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
          <span class="n">c</span> <span class="o">=</span> <span class="nf">aFunction</span><span class="p">(</span><span class="n">anObject</span><span class="p">,</span> <span class="nb">self</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span> <span class="n">aContext</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">aFunction</span><span class="p">(</span><span class="n">anObject</span><span class="p">,</span> <span class="nb">self</span><span class="p">[</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">aContext</span><span class="p">)</span> <span class="o">==</span> <span class="n">CPOrderedSame</span><span class="p">)</span>
                <span class="n">mid</span><span class="o">++</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">CPNotFound</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the index of \c anObject in the array, which must be sorted in the same order as</span>
<span class="cm">    calling sortUsingDescriptors: with the descriptors passed to this method would result in. </span>
<span class="cm">    @param anObject the object to search for</span>
<span class="cm">    @param descriptors the array of descriptors to use to compare each item in the array that we search. the same</span>
<span class="cm">    descriptors should have been used to sort the array (or to maintain its sorted order).</span>
<span class="cm">    @return the index of the object, or \c CPNotFound if it was not found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">sortedByDescriptors:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>descriptors
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">indexOfObject</span><span class="o">:</span><span class="n">anObject</span> <span class="n">sortedByFunction</span><span class="o">:</span><span class="kd">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptors</span> <span class="n">count</span><span class="p">],</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CPOrderedSame</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
            <span class="k">if</span><span class="p">((</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptors</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="n">compareObject</span><span class="o">:</span><span class="n">lhs</span> <span class="n">withObject</span><span class="o">:</span><span class="n">rhs</span><span class="p">])</span> <span class="o">!=</span> <span class="n">CPOrderedSame</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the last object in the array. If the array is empty, returns \c nil/</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">lastObject</span>
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">];</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span> <span class="k">return</span> <span class="kc">nil</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nb">self</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the object at index \c anIndex.</span>
<span class="cm">    @throws CPRangeException if \c anIndex is out of bounds</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">objectAtIndex:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>anIndex
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anIndex</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="o">||</span> <span class="n">anIndex</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPRangeException</span> <span class="n">reason</span><span class="o">:</span><span class="s">@&quot;index (&quot;</span> <span class="o">+</span> <span class="n">anIndex</span> <span class="o">+</span> <span class="s">@&quot;) beyond bounds (&quot;</span> <span class="o">+</span> <span class="n">length</span> <span class="o">+</span> <span class="s">@&quot;)&quot;</span><span class="p">];</span>

    <span class="k">return</span> <span class="nb">self</span><span class="p">[</span><span class="n">anIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the objects at \c indexes in a new CPArray.</span>
<span class="cm">    @param indexes the set of indices</span>
<span class="cm">    @throws CPRangeException if any of the indices is greater than or equal to the length of the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">objectsAtIndexes:</span><span class="p">(</span><span class="kt">CPIndexSet</span><span class="p">)</span>indexes
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="n">CPNotFound</span><span class="p">,</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">while</span><span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span> <span class="n">indexGreaterThanIndex</span><span class="o">:</span><span class="n">index</span><span class="p">])</span> <span class="o">!==</span> <span class="n">CPNotFound</span><span class="p">)</span>
        <span class="p">[</span><span class="n">objects</span> <span class="n">addObject</span><span class="o">:</span><span class="p">[</span><span class="nb">self</span> <span class="n">objectAtIndex</span><span class="o">:</span><span class="n">index</span><span class="p">]];</span>

    <span class="k">return</span> <span class="n">objects</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns an enumerator describing the array sequentially</span>
<span class="cm">    from the first to the last element. You should not modify</span>
<span class="cm">    the array during enumeration.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPEnumerator</span><span class="p">)</span><span class="nf">objectEnumerator</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">_CPArrayEnumerator</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithArray</span><span class="o">:</span><span class="nb">self</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns an enumerator describing the array sequentially</span>
<span class="cm">    from the last to the first element. You should not modify</span>
<span class="cm">    the array during enumeration.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPEnumerator</span><span class="p">)</span><span class="nf">reverseObjectEnumerator</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">_CPReverseArrayEnumerator</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithArray</span><span class="o">:</span><span class="nb">self</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Sending messages to elements</span>
<span class="cm">/*!</span>
<span class="cm">    Sends each element in the array a message.</span>
<span class="cm">    @param aSelector the selector of the message to send</span>
<span class="cm">    @throws CPInvalidArgumentException if \c aSelector is \c nil</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">makeObjectsPerformSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span>aSelector
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aSelector</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPInvalidArgumentException</span> <span class="n">reason</span><span class="o">:</span><span class="s">&quot;makeObjectsPerformSelector: &#39;aSelector&#39; can&#39;t be nil&quot;</span><span class="p">];</span>
    
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
        
    <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
        <span class="nf">objj_msgSend</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">aSelector</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Sends each element in the array a message with an argument.</span>
<span class="cm">    @param aSelector the selector of the message to send</span>
<span class="cm">    @param anObject the first argument of the message</span>
<span class="cm">    @throws CPInvalidArgumentException if \c aSelector is \c nil</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">makeObjectsPerformSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span>aSelector <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aSelector</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPInvalidArgumentException</span> <span class="n">reason</span><span class="o">:</span><span class="s">&quot;makeObjectsPerformSelector:withObject &#39;aSelector&#39; can&#39;t be nil&quot;</span><span class="p">];</span>

    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
        <span class="n">count</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
        
    <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span> 
        <span class="nf">objj_msgSend</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">anObject</span><span class="p">);</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">makeObjectsPerformSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span>aSelector <span class="nf">withObjects:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>objects
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">aSelector</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPInvalidArgumentException</span> <span class="n">reason</span><span class="o">:</span><span class="s">&quot;makeObjectsPerformSelector:withObjects: &#39;aSelector&#39; can&#39;t be nil&quot;</span><span class="p">];</span>

    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">length</span><span class="p">,</span>
        <span class="n">argumentsArray</span> <span class="o">=</span> <span class="p">[</span><span class="kc">nil</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="n">objects</span> <span class="o">||</span> <span class="p">[]);</span>

    <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">argumentsArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="n">objj_msgSend</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nb">this</span><span class="p">,</span> <span class="n">argumentsArray</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Comparing arrays</span>
<span class="cm">/*!</span>
<span class="cm">    Returns the first object found in the receiver (starting at index 0) which is present in the</span>
<span class="cm">    \c otherArray as determined by using the \c -containsObject: method.</span>
<span class="cm">    @return the first object found, or \c nil if no common object was found.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">firstObjectCommonWithArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">anArray</span> <span class="n">count</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">;</span>
    
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">];</span>

    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span><span class="p">([</span><span class="n">anArray</span> <span class="n">containsObject</span><span class="o">:</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">return</span> <span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="k">return</span> <span class="kc">nil</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns true if anArray contains exactly the same objects as the reciever.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqualToArray:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">===</span> <span class="n">anArray</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">YES</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="n">anArray</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">NO</span><span class="p">;</span>
    
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">];</span>
    
    <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">lhs</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">anArray</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        
        <span class="c1">// If they&#39;re not equal, and either doesn&#39;t have an isa, or they&#39;re !isEqual (not isEqual)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span> <span class="o">!==</span> <span class="n">rhs</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">lhs</span><span class="p">.</span><span class="n">isa</span> <span class="o">||</span> <span class="o">!</span><span class="n">rhs</span><span class="p">.</span><span class="n">isa</span> <span class="o">||</span> <span class="o">!</span><span class="p">[</span><span class="n">lhs</span> <span class="n">isEqual</span><span class="o">:</span><span class="n">rhs</span><span class="p">]))</span>
            <span class="k">return</span> <span class="kc">NO</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="k">return</span> <span class="kc">YES</span><span class="p">;</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEqual:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">===</span> <span class="n">anObject</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">YES</span><span class="p">;</span>
    
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">anObject</span> <span class="n">isKindOfClass</span><span class="o">:</span><span class="p">[</span><span class="n">CPArray</span> <span class="n">class</span><span class="p">]])</span>
        <span class="k">return</span> <span class="kc">NO</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">isEqualToArray</span><span class="o">:</span><span class="n">anObject</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Deriving new arrays</span>
<span class="cm">/*!</span>
<span class="cm">    Returns a copy of this array plus \c anObject inside the copy.</span>
<span class="cm">    @param anObject the object to be added to the array copy</span>
<span class="cm">    @throws CPInvalidArgumentException if \c anObject is \c nil</span>
<span class="cm">    @return a new array that should be n+1 in size compared to the receiver.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">arrayByAddingObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">anObject</span> <span class="o">===</span> <span class="kc">nil</span> <span class="o">||</span> <span class="n">anObject</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPInvalidArgumentException</span>
                    <span class="n">reason</span><span class="o">:</span><span class="s">&quot;arrayByAddingObject: object can&#39;t be nil&quot;</span><span class="p">];</span>

    <span class="kd">var</span> <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">copy</span><span class="p">];</span>
    
    <span class="n">array</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="n">anObject</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a new array which is the concatenation of \c self and otherArray (in this precise order).</span>
<span class="cm">    @param anArray the array that will be concatenated to the receiver&#39;s copy</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">arrayByAddingObjectsFromArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">concat</span><span class="p">(</span><span class="n">anArray</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  </span>
<span class="cm">- (CPArray)filteredArrayUsingPredicate:(CPPredicate)aPredicate</span>
<span class="cm">{</span>
<span class="cm">    var i= 0, </span>
<span class="cm">        count = [self count],</span>
<span class="cm">        array = [CPArray array];</span>
<span class="cm">    </span>
<span class="cm">    for(; i&lt;count; ++i)</span>
<span class="cm">        if(aPredicate.evaluateWithObject(self[i]))</span>
<span class="cm">            array.push(self[i]);</span>
<span class="cm">    </span>
<span class="cm">    return array;</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a subarray of the receiver containing the objects found in the specified range \c aRange.</span>
<span class="cm">    @param aRange the range of objects to be copied into the subarray</span>
<span class="cm">    @throws CPRangeException if the specified range exceeds the bounds of the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">subarrayWithRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aRange</span><span class="p">.</span><span class="n">location</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nf">CPMaxRange</span><span class="p">(</span><span class="n">aRange</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPRangeException</span> <span class="n">reason</span><span class="o">:</span><span class="s">&quot;subarrayWithRange: aRange out of bounds&quot;</span><span class="p">];</span>

    <span class="k">return</span> <span class="nf">slice</span><span class="p">(</span><span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="nf">CPMaxRange</span><span class="p">(</span><span class="n">aRange</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Sorting arrays</span>
<span class="cm">/*</span>
<span class="cm">    Not yet described.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">sortedArrayUsingDescriptors:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>descriptors
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">sorted</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">copy</span><span class="p">];</span>
    
    <span class="p">[</span><span class="n">sorted</span> <span class="n">sortUsingDescriptors</span><span class="o">:</span><span class="n">descriptors</span><span class="p">];</span>
    
    <span class="k">return</span> <span class="n">sorted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Return a copy of the receiver sorted using the function passed into the first parameter.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">sortedArrayUsingFunction:</span><span class="p">(</span><span class="kt">Function</span><span class="p">)</span>aFunction
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">sortedArrayUsingFunction</span><span class="o">:</span><span class="n">aFunction</span> <span class="n">context</span><span class="o">:</span><span class="kc">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns an array in which the objects are ordered according</span>
<span class="cm">    to a sort with \c aFunction. This invokes</span>
<span class="cm">    \c -sortUsingFunction:context.</span>
<span class="cm">    @param aFunction a JavaScript &#39;Function&#39; type that compares objects</span>
<span class="cm">    @param aContext context information</span>
<span class="cm">    @return a new sorted array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">sortedArrayUsingFunction:</span><span class="p">(</span><span class="kt">Function</span><span class="p">)</span>aFunction <span class="nf">context:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>aContext
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">sorted</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">copy</span><span class="p">];</span>
    
    <span class="p">[</span><span class="n">sorted</span> <span class="n">sortUsingFunction</span><span class="o">:</span><span class="n">aFunction</span> <span class="n">context</span><span class="o">:</span><span class="n">aContext</span><span class="p">];</span>
    
    <span class="k">return</span> <span class="n">sorted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a new array in which the objects are ordered according to a sort with \c aSelector.</span>
<span class="cm">    @param aSelector the selector that will perform object comparisons</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">sortedArrayUsingSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span>aSelector
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">sorted</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">copy</span><span class="p">]</span>
    
    <span class="p">[</span><span class="n">sorted</span> <span class="n">sortUsingSelector</span><span class="o">:</span><span class="n">aSelector</span><span class="p">];</span>

    <span class="k">return</span> <span class="n">sorted</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Working with string elements</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a string formed by concatenating the objects in the</span>
<span class="cm">    receiver, with the specified separator string inserted between each part.</span>
<span class="cm">    If the element is a Objective-J object, then the \c -description</span>
<span class="cm">    of that object will be used, otherwise the default JavaScript representation will be used.</span>
<span class="cm">    @param aString the separator that will separate each object string</span>
<span class="cm">    @return the string representation of the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPString</span><span class="p">)</span><span class="nf">componentsJoinedByString:</span><span class="p">(</span><span class="kt">CPString</span><span class="p">)</span>aString
<span class="p">{</span>
    <span class="c1">// Objective-J objects get &quot;description&quot; called on them automatically when coerced to strings</span>
    <span class="c1">// (see &quot;objj_object.prototype.toString&quot; at bottom of CPObject.j)</span>
    <span class="k">return</span> <span class="nf">join</span><span class="p">(</span><span class="n">aString</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Creating a description of the array</span>

<span class="cm">/*!</span>
<span class="cm">    Returns a human readable description of this array and it&#39;s elements.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPString</span><span class="p">)</span><span class="nf">description</span>
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">],</span>
        <span class="n">description</span> <span class="o">=</span> <span class="sc">&#39;(&#39;</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

        <span class="kd">var</span> <span class="n">object</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
            <span class="n">objectDescription</span> <span class="o">=</span> <span class="n">object</span> <span class="o">&amp;&amp;</span> <span class="n">object</span><span class="p">.</span><span class="n">isa</span> <span class="o">?</span> <span class="p">[</span><span class="n">object</span> <span class="n">description</span><span class="p">]</span> <span class="o">:</span> <span class="n">object</span> <span class="o">+</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

        <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">objectDescription</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">).</span><span class="nf">join</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!==</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>

        <span class="n">description</span> <span class="o">+=</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">description</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Collecting paths</span>
<span class="cm">/*!</span>
<span class="cm">    Returns a new array subset formed by selecting the elements that have</span>
<span class="cm">    filename extensions from \c filterTypes. Only elements</span>
<span class="cm">    that are of type CPString are candidates for inclusion in the returned array.</span>
<span class="cm">    @param filterTypes an array of CPString objects that contain file extensions (without the &#39;.&#39;)</span>
<span class="cm">    @return a new array with matching paths</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">pathsMatchingExtensions:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>filterTypes
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">],</span>
        <span class="n">array</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">for</span><span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">isa</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="n">isKindOfClass</span><span class="o">:</span><span class="p">[</span><span class="n">CPString</span> <span class="n">class</span><span class="p">]]</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">filterTypes</span> <span class="n">containsObject</span><span class="o">:</span><span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="n">pathExtension</span><span class="p">]])</span>
            <span class="n">array</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nb">self</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
    
    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Key value coding</span>
<span class="cm">/*!</span>
<span class="cm">    Sets the key-value for each element in the array.</span>
<span class="cm">    @param aValue the value for the coding</span>
<span class="cm">    @param aKey the key for the coding</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>aValue <span class="nf">forKey:</span><span class="p">(</span><span class="kt">CPString</span><span class="p">)</span>aKey
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">];</span>
    
    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">[</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">setValue</span><span class="o">:</span><span class="n">aValue</span> <span class="n">forKey</span><span class="o">:</span><span class="n">aKey</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Returns the value for \c aKey from each element in the array.</span>
<span class="cm">    @param aKey the key to return the value for</span>
<span class="cm">    @return an array of containing a value for each element in the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">valueForKey:</span><span class="p">(</span><span class="kt">CPString</span><span class="p">)</span>aKey
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">],</span>
        <span class="n">array</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">array</span><span class="p">.</span><span class="nf">push</span><span class="p">([</span><span class="nb">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">valueForKey</span><span class="o">:</span><span class="n">aKey</span><span class="p">]);</span>
    
    <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Copying arrays</span>

<span class="cm">/*!</span>
<span class="cm">    Makes a copy of the receiver.</span>
<span class="cm">    @return a new CPArray copy</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">copy</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
    
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">CPArray</span><span class="p">(</span><span class="nl">CPMutableArray</span>)

<span class="c1">// Creating arrays</span>
<span class="cm">/*!</span>
<span class="cm">    Creates an array able to store at least  \c aCapacity</span>
<span class="cm">    items. Because CPArray is backed by JavaScript arrays,</span>
<span class="cm">    this method ends up simply returning a regular array.</span>
<span class="cm">*/</span>
+ <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">arrayWithCapacity:</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>aCapacity
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithCapacity</span><span class="o">:</span><span class="n">aCapacity</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Initializes an array able to store at least \c aCapacity items. Because CPArray</span>
<span class="cm">    is backed by JavaScript arrays, this method ends up simply returning a regular array.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithCapacity:</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>aCapacity
<span class="p">{</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Adding and replacing objects</span>
<span class="cm">/*!</span>
<span class="cm">    Adds \c anObject to the end of the array.</span>
<span class="cm">    @param anObject the object to add to the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="nf">push</span><span class="p">(</span><span class="n">anObject</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Adds the objects in \c anArray to the receiver array.</span>
<span class="cm">    @param anArray the array of objects to add to the end of the receiver</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addObjectsFromArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="n">splice</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="p">[</span><span class="n">length</span><span class="p">,</span> <span class="mi">0</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="n">anArray</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Inserts an object into the receiver at the specified location.</span>
<span class="cm">    @param anObject the object to insert into the array</span>
<span class="cm">    @param anIndex the location to insert \c anObject at</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">insertObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">atIndex:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>anIndex
<span class="p">{</span>
    <span class="nf">splice</span><span class="p">(</span><span class="n">anIndex</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">anObject</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Inserts the objects in the provided array into the receiver at the indexes specified.</span>
<span class="cm">    @param objects the objects to add to this array</span>
<span class="cm">    @param anIndexSet the indices for the objects</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">insertObjects:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>objects <span class="nf">atIndexes:</span><span class="p">(</span><span class="kt">CPIndexSet</span><span class="p">)</span>indexes
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">indexesCount</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span> <span class="n">count</span><span class="p">],</span>
        <span class="n">objectsCount</span> <span class="o">=</span> <span class="p">[</span><span class="n">objects</span> <span class="n">count</span><span class="p">];</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">indexesCount</span> <span class="o">!==</span> <span class="n">objectsCount</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPRangeException</span> <span class="n">reason</span><span class="o">:</span><span class="s">&quot;the counts of the passed-in array (&quot;</span> <span class="o">+</span> <span class="n">objectsCount</span> <span class="o">+</span> <span class="s">&quot;) and index set (&quot;</span> <span class="o">+</span> <span class="n">indexesCount</span> <span class="o">+</span> <span class="s">&quot;) must be identical.&quot;</span><span class="p">];</span>
    
    <span class="kd">var</span> <span class="n">lastIndex</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span> <span class="n">lastIndex</span><span class="p">];</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">lastIndex</span> <span class="o">&gt;=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">]</span> <span class="o">+</span> <span class="n">indexesCount</span><span class="p">)</span>
        <span class="p">[</span><span class="n">CPException</span> <span class="n">raise</span><span class="o">:</span><span class="n">CPRangeException</span> <span class="n">reason</span><span class="o">:</span><span class="s">&quot;the last index (&quot;</span> <span class="o">+</span> <span class="n">lastIndex</span> <span class="o">+</span> <span class="s">&quot;) must be less than the sum of the original count (&quot;</span> <span class="o">+</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;) and the insertion count (&quot;</span> <span class="o">+</span> <span class="n">indexesCount</span> <span class="o">+</span> <span class="s">&quot;).&quot;</span><span class="p">];</span>    
    
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">currentIndex</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span> <span class="n">firstIndex</span><span class="p">];</span>
 
    <span class="k">for</span> <span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">objectsCount</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">,</span> <span class="n">currentIndex</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexes</span> <span class="n">indexGreaterThanIndex</span><span class="o">:</span><span class="n">currentIndex</span><span class="p">])</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">insertObject</span><span class="o">:</span><span class="n">objects</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="n">atIndex</span><span class="o">:</span><span class="n">currentIndex</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Replaces the element at \c anIndex with \c anObject.</span>
<span class="cm">    The current element at position \c anIndex will be removed from the array.</span>
<span class="cm">    @param anIndex the position in the array to place \c anObject</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">replaceObjectAtIndex:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>anIndex <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">anIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">anObject</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Replace the elements at the indices specified by \c anIndexSet with</span>
<span class="cm">    the objects in \c objects.</span>
<span class="cm">    @param anIndexSet the set of indices to array positions that will be replaced</span>
<span class="cm">    @param objects the array of objects to place in the specified indices</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">replaceObjectsAtIndexes:</span><span class="p">(</span><span class="kt">CPIndexSet</span><span class="p">)</span>anIndexSet <span class="nf">withObjects:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>objects
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">anIndexSet</span> <span class="n">firstIndex</span><span class="p">];</span>
   
    <span class="k">while</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">CPNotFound</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">replaceObjectAtIndex</span><span class="o">:</span><span class="n">index</span> <span class="n">withObject</span><span class="o">:</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]];</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">anIndexSet</span> <span class="n">indexGreaterThanIndex</span><span class="o">:</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Replaces some of the receiver&#39;s objects with objects from \c anArray. Specifically, the elements of the</span>
<span class="cm">    receiver in the range specified by \c aRange,</span>
<span class="cm">    with the elements of \c anArray in the range specified by \c otherRange.</span>
<span class="cm">    @param aRange the range of elements to be replaced in the receiver</span>
<span class="cm">    @param anArray the array to retrieve objects for placement into the receiver</span>
<span class="cm">    @param otherRange the range of objects in \c anArray to pull from for placement into the receiver</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">replaceObjectsInRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange <span class="nf">withObjectsFromArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray <span class="nf">range:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>otherRange
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">otherRange</span><span class="p">.</span><span class="n">location</span> <span class="o">&amp;&amp;</span> <span class="n">otherRange</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">count</span><span class="p">])</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">replaceObjectsInRange</span><span class="o">:</span><span class="n">aRange</span> <span class="n">withObjectsFromArray</span><span class="o">:</span><span class="n">anArray</span><span class="p">];</span>
    <span class="k">else</span>
        <span class="n">splice</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="p">[</span><span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">aRange</span><span class="p">.</span><span class="n">length</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="n">anArray</span> <span class="n">subarrayWithRange</span><span class="o">:</span><span class="n">otherRange</span><span class="p">]));</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Replaces some of the receiver&#39;s objects with the objects from</span>
<span class="cm">    \c anArray. Specifically, the elements of the</span>
<span class="cm">    receiver in the range specified by \c aRange.</span>
<span class="cm">    @param aRange the range of elements to be replaced in the receiver</span>
<span class="cm">    @param anArray the array to retrieve objects for placement into the receiver</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">replaceObjectsInRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange <span class="nf">withObjectsFromArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="n">splice</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="p">[</span><span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">aRange</span><span class="p">.</span><span class="n">length</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="n">anArray</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Sets the contents of the receiver to be identical to the contents of \c anArray.</span>
<span class="cm">    @param anArray the array of objects used to replace the receiver&#39;s objects</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="n">anArray</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="n">splice</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">].</span><span class="nf">concat</span><span class="p">(</span><span class="n">anArray</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Removing Objects</span>
<span class="cm">/*!</span>
<span class="cm">    Removes all objects from this array.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeAllObjects</span>
<span class="p">{</span>
    <span class="nf">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Removes the last object from the array.</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeLastObject</span>
<span class="p">{</span>
    <span class="nf">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Removes all entries of \c anObject from the array.</span>
<span class="cm">    @param anObject the object whose entries are to be removed</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="p">[</span><span class="nb">self</span> <span class="n">removeObject</span><span class="o">:</span><span class="n">anObject</span> <span class="n">inRange</span><span class="o">:</span><span class="nf">CPMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">)];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Removes all entries of \c anObject from the array, in the range specified by \c aRange.</span>
<span class="cm">    @param anObject the object to remove</span>
<span class="cm">    @param aRange the range to search in the receiver for the object</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">inRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">indexOfObject</span><span class="o">:</span><span class="n">anObject</span> <span class="n">inRange</span><span class="o">:</span><span class="n">aRange</span><span class="p">])</span> <span class="o">!=</span> <span class="n">CPNotFound</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">removeObjectAtIndex</span><span class="o">:</span><span class="n">index</span><span class="p">];</span>
        <span class="n">aRange</span> <span class="o">=</span> <span class="nf">CPIntersectionRange</span><span class="p">(</span><span class="nf">CPMakeRange</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">index</span><span class="p">),</span> <span class="n">aRange</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Removes the object at \c anIndex.</span>
<span class="cm">    @param anIndex the location of the element to be removed</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObjectAtIndex:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>anIndex
<span class="p">{</span>
    <span class="nf">splice</span><span class="p">(</span><span class="n">anIndex</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Removes the objects at the indices specified by \c CPIndexSet.</span>
<span class="cm">    @param anIndexSet the indices of the elements to be removed from the array</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObjectsAtIndexes:</span><span class="p">(</span><span class="kt">CPIndexSet</span><span class="p">)</span>anIndexSet
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">anIndexSet</span> <span class="n">lastIndex</span><span class="p">];</span>
   
    <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">CPNotFound</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">removeObjectAtIndex</span><span class="o">:</span><span class="n">index</span><span class="p">];</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">anIndexSet</span> <span class="n">indexLessThanIndex</span><span class="o">:</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Remove the first instance of \c anObject from the array.</span>
<span class="cm">    The search for the object is done using \c ==.</span>
<span class="cm">    @param anObject the object to remove</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObjectIdenticalTo:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject
<span class="p">{</span>
    <span class="p">[</span><span class="nb">self</span> <span class="n">removeObjectIdenticalTo</span><span class="o">:</span><span class="n">anObject</span> <span class="n">inRange</span><span class="o">:</span><span class="nf">CPMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">])];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Remove the first instance of \c anObject from the array,</span>
<span class="cm">    within the range specified by \c aRange.</span>
<span class="cm">    The search for the object is done using \c ==.</span>
<span class="cm">    @param anObject the object to remove</span>
<span class="cm">    @param aRange the range in the array to search for the object</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObjectIdenticalTo:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>anObject <span class="nf">inRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">count</span><span class="p">];</span>
    
    <span class="k">while</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">indexOfObjectIdenticalTo</span><span class="o">:</span><span class="n">anObject</span> <span class="n">inRange</span><span class="o">:</span><span class="n">aRange</span><span class="p">])</span> <span class="o">!==</span> <span class="n">CPNotFound</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">removeObjectAtIndex</span><span class="o">:</span><span class="n">index</span><span class="p">];</span>
        <span class="n">aRange</span> <span class="o">=</span> <span class="nf">CPIntersectionRange</span><span class="p">(</span><span class="nf">CPMakeRange</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="n">index</span><span class="p">),</span> <span class="n">aRange</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Remove the objects in \c anArray from the receiver array.</span>
<span class="cm">    @param anArray the array of objects to remove from the receiver</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObjectsInArray:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>anArray
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">anArray</span> <span class="n">count</span><span class="p">];</span>
        
    <span class="k">for</span> <span class="p">(;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">index</span><span class="p">)</span>
        <span class="p">[</span><span class="nb">self</span> <span class="n">removeObject</span><span class="o">:</span><span class="n">anArray</span><span class="p">[</span><span class="n">index</span><span class="p">]];</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Removes all the objects in the specified range from the receiver.</span>
<span class="cm">    @param aRange the range of objects to remove</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeObjectsInRange:</span><span class="p">(</span><span class="kt">CPRange</span><span class="p">)</span>aRange
<span class="p">{</span>
    <span class="nf">splice</span><span class="p">(</span><span class="n">aRange</span><span class="p">.</span><span class="n">location</span><span class="p">,</span> <span class="n">aRange</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Rearranging objects</span>
<span class="cm">/*!</span>
<span class="cm">    Swaps the elements at the two specified indices.</span>
<span class="cm">    @param anIndex the first index to swap from</span>
<span class="cm">    @param otherIndex the second index to swap from</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">exchangeObjectAtIndex:</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>anIndex <span class="nf">withObjectAtIndex:</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span>otherIndex
<span class="p">{</span>
    <span class="kd">var</span> <span class="n">temporary</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">anIndex</span><span class="p">];</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">anIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">otherIndex</span><span class="p">];</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">otherIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">temporary</span><span class="p">;</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span><span class="nf">sortUsingDescriptors:</span><span class="p">(</span><span class="kt">CPArray</span><span class="p">)</span>descriptors
<span class="p">{</span>
    <span class="nf">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">count</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptors</span> <span class="n">count</span><span class="p">],</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">CPOrderedSame</span><span class="p">;</span>
        
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
            <span class="k">if</span><span class="p">((</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">descriptors</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="n">compareObject</span><span class="o">:</span><span class="n">lhs</span> <span class="n">withObject</span><span class="o">:</span><span class="n">rhs</span><span class="p">])</span> <span class="o">!=</span> <span class="n">CPOrderedSame</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Sorts the receiver array using a JavaScript function as a comparator, and a specified context.</span>
<span class="cm">    @param aFunction a JavaScript function that will be called to compare objects</span>
<span class="cm">    @param aContext an object that will be passed to \c aFunction with comparison</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sortUsingFunction:</span><span class="p">(</span><span class="kt">Function</span><span class="p">)</span>aFunction <span class="nf">context:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span>aContext
<span class="p">{</span>
    <span class="nf">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">aFunction</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">aContext</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>

<span class="cm">/*!</span>
<span class="cm">    Sorts the receiver array using an Objective-J method as a comparator.</span>
<span class="cm">    @param aSelector the selector for the method to call for comparison</span>
<span class="cm">*/</span>
- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sortUsingSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span>aSelector
<span class="p">{</span>
    <span class="nf">sort</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">objj_msgSend</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">aSelector</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">CPArray</span> <span class="p">(</span><span class="nl">CPCoding</span>)

- <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithCoder:</span><span class="p">(</span><span class="kt">CPCoder</span><span class="p">)</span>aCoder
<span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">aCoder</span> <span class="n">decodeObjectForKey</span><span class="o">:</span><span class="s">@&quot;CP.objects&quot;</span><span class="p">];</span>
<span class="p">}</span>

- <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeWithCoder:</span><span class="p">(</span><span class="kt">CPCoder</span><span class="p">)</span>aCoder
<span class="p">{</span>
    <span class="p">[</span><span class="n">aCoder</span> <span class="n">_encodeArrayOfObjects</span><span class="o">:</span><span class="nb">self</span> <span class="n">forKey</span><span class="o">:</span><span class="s">@&quot;CP.objects&quot;</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="cm">/*!</span>
<span class="cm">    @class CPMutableArray</span>
<span class="cm">    @ingroup compatability</span>

<span class="cm">    This class is just an empty subclass of CPArray.</span>
<span class="cm">    CPArray already implements mutable methods and</span>
<span class="cm">    this class only exists for source compatability.</span>
<span class="cm">*/</span>
<span class="k">@implementation</span> <span class="nc">CPMutableArray</span> <span class="o">:</span> <span class="nc">CPArray</span>

<span class="k">@end</span>

<span class="nb">Array</span><span class="p">.</span><span class="k">prototype</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="n">CPArray</span><span class="p">;</span>
<span class="p">[</span><span class="n">CPArray</span> <span class="n">initialize</span><span class="p">];</span>
</pre></div>
</body>
</html>
